        Input                   / Leer número de casos
        Store   cases          / Guardar en variable 'cases'
        Load    cases
        Subt    one            / Restar 1 porque el contador i inicia en 0
        Store   cases          / Actualizar 'cases' para contar desde 0

/ -------- Bucle principal para procesar cada caso --------
while,  Clear                 
        Store   i             / Inicializar contador i = 0
        Clear
        Store   max_value     / Inicializar el valor máximo global a 0

loop,   Load    i
        Subt    cases
        Skipcond 800          / Si i >= cases, terminar
        Jump    bodywhile     / Si no, procesar el caso
        Halt                  / Fin del programa

/ -------- Leer número y preparar la secuencia de Collatz --------
bodywhile, Input
        Store   num           / Guardar el número de entrada
        Store   max_value     / Reiniciar el máximo local con el número leído

/ -------- Generar la secuencia de Collatz --------
while2, Load    num
        Subt    one
        Skipcond 400          / Si num == 1, termina la secuencia
        Jump    bodywhile2
        Jump    endwhile2     / Salir del bucle si num == 1

/ -------- Verificar si el número es par o impar --------
bodywhile2, Load    num
        Store   mod_a
        JnS     mod           / Llamar a subrutina módulo (num % 2)
        Store   remainder     / Guardar el resultado del módulo
        Skipcond 400          / Si el módulo fue 0, el número es par
        Jump    else          / Si no fue 0, el número es impar

/ -------- Si el número es par --------
        Load    num
        Store   div_a
        JnS     div           / Llamar a subrutina para num / 2
        Store   num           / Actualizar num con el nuevo valor

        Jump    while2        / Repetir con el nuevo número

/ -------- Si el número es impar --------
else,   Load    num
        Store   mult_a
        JnS     mult          / Llamar a subrutina para 3 * num
        Add     one           / 3 * num + 1
        Store   num

        / Comparar con max_value
        Load    num
        Subt    max_value
        Skipcond 000          / Si num < max_value
        Jump    ell           / Entonces actualizar max_value
        Jump    while2        / Si no, continuar con while2

ell,    Load    num
        Store   max_value     / Actualizar el máximo local
        Jump    while2        / Repetir con el nuevo num

/ -------- Fin de secuencia Collatz para un número --------
endwhile2,   Load    max_value
             Output            / Imprimir el máximo valor encontrado en la secuencia
             Load    i
             Add     one
             Store   i         / i++
             Jump    loop      / Siguiente caso

/ -------- Variables --------
cases,      DEC     0          / Número de casos
num,        DEC     0          / Número actual en la secuencia
remainder,  DEC     0          / Resultado de num % 2
one,        DEC     1          / Constante 1
i,          DEC     0          / Contador de casos
max_value,  DEC     0          / Máximo valor en la secuencia

/ -------- Subrutina: Módulo (num % 2) --------
mod,        DEC     0
mod_while,  Load    mod_a
            Subt    mod_two
            Skipcond 000       / Si resultado < 0, terminar
            Jump    mod_bodywhile
            Jump    mod_endwhile

mod_bodywhile, Store mod_a     / Actualizar valor
            Jump    mod_while

mod_endwhile, Load mod_a       / Devolver el residuo
            JumpI   mod

mod_a,      DEC     0
mod_two,    DEC     2

/ -------- Subrutina: División (num / 2) --------
div,        DEC     0
            Clear
            Store   div_i      / Inicializar contador i = 0

div_while,  Load    div_a
            Subt    div_two
            Skipcond 000       / Si < 0, terminar
            Jump    div_bodywhile
            Jump    div_endwhile

div_bodywhile, Store div_a
            Load    div_i
            Add     div_one
            Store   div_i
            Jump    div_while

div_endwhile, Load div_i
            JumpI   div

div_a,      DEC     0
div_i,      DEC     0
div_one,    DEC     1
div_two,    DEC     2

/ -------- Subrutina: Multiplicación (num * 3) --------
mult,       DEC     0
            Clear
            Store   mult_i     / mult_i = 0
            Store   mult_m     / mult_m = 0

mult_while, Load    mult_i
            Subt    mult_a
            Skipcond 000       / Si mult_i >= mult_a, terminar
            Jump    mult_endwhile

            Load    mult_m
            Add     mult_three
            Store   mult_m

            Load    mult_i
            Add     mult_one
            Store   mult_i

            Jump    mult_while

mult_endwhile, Load mult_m
            JumpI   mult

mult_a,     DEC     0
mult_i,     DEC     0
mult_m,     DEC     0
mult_one,   DEC     1
mult_three, DEC     3
